---
description: 分析代码的性能、质量和安全问题，提供具体优化方案
argument-hint: [file-path] (不传参数则优化整个项目)
---

# 代码优化分析

${1:+分析 `$1` 的}${1:-分析整个项目的}性能、质量和安全问题，提供具体优化方案

${1:+@$1}

## 分析范围

${1:+**目标文件**：`$1`}${1:-**整个项目**：扫描所有源代码文件，重点关注：
- 核心业务逻辑文件
- 性能关键路径
- 安全敏感模块
- 高频使用组件}

## 分析重点

### 1. 关键问题（优先处理）
- **安全漏洞**：输入验证、权限控制、依赖漏洞
- **性能瓶颈**：内存泄漏、算法复杂度、阻塞操作
- **错误处理**：缺少 try-catch、null/undefined 检查

### 2. 代码质量
- **重复代码**：提取公共逻辑
- **复杂函数**：拆分超过 30 行的函数
- **圈复杂度**：降低到 10 以下

### 3. 现代化改进
- **现代语法**：ES6+、可选链 `?.`、空值合并 `??`、async/await
- **类型安全**：TypeScript 类型定义、严格模式
- **性能优化**：
  - 前端：组件记忆化、懒加载、代码分割
  - 后端：数据库索引、缓存、并发优化

## 输出要求

${1:+### 单文件优化
1. **问题清单**：按优先级列出发现的问题（P0/P1/P2）
2. **优化代码**：创建新文件输出优化后的代码，保持原文件不变
   - 命名规则：`$1.optimized` 或在同目录下创建 `optimized/` 子目录
3. **改进说明**：简要说明主要改进点和预期效果
4. **风险提示**：如有兼容性影响需提前说明}${1:-### 项目整体优化
1. **问题清单**：按文件/模块列出发现的问题，标注优先级
2. **优化计划**：
   - P0 关键问题：立即修复的文件清单
   - P1 重要问题：计划优化的模块
   - P2 改进建议：长期优化方向
3. **优先级文件**：针对最关键的 3-5 个文件创建优化版本（新文件）
4. **架构建议**：整体架构层面的改进方向}

## 实施原则

- ✅ 安全优先，不引入新风险
- ✅ 保持向后兼容
- ✅ 代码简洁高效，使用现代语法
- ✅ **YAGNI 原则**：只优化真正需要的部分，避免过度优化
- ✅ **不修改原文件**：所有优化代码作为新文件输出

## 优化约束

- ⚠️ 只修复已知问题和明显的性能瓶颈
- ⚠️ 不添加未来可能需要的功能或抽象
- ⚠️ 不为了"完美"而重写可工作的代码
- ⚠️ 优先考虑可读性和可维护性，而非极致性能

## 文档输出

${1:+- 分析报告：`docs/optimize/$1_analysis.md`
- 优化文件：`$1.optimized` 或 `optimized/$1`（原文件保持不变）}${1:-- 整体分析：`docs/optimize/project_optimization_plan.md`
- 优化文件：在各文件目录下创建 `optimized/` 子目录存放优化版本}
